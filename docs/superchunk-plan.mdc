# SuperChunk Plan (Rules)

## Objectives
Hierarchical RAG for long transcripts without timestamps. Extract locally with high attention density; synthesize globally from retrieved slices. Preserve rare items, surface contradictions, verify top claims.

## Hard Constraints
- Use **character spans** + **paragraph indices** only.
- **Structured outputs** (schema‑validated JSON) for every extractor/linker.
- **Never** prompt with full transcript; work on chunks + retrieved slices.
- Enforce **exact counts** and **quote cap** (= config.max_quote_words).
- Pre‑check input/output **token budgets**.

## Persistent Checklist
Before any work:
1) Open `docs/todo.md`.
2) Find the **first unchecked** task.
3) Do it, **check it off**, commit with a brief message ("chore: complete <task>"), and move to the next.
4) Repeat until all are checked.

## Adaptive Chunking
- Compute **PrecisionScore** from skim signals. Episode: ≥0.55 Precision; ≤0.45 Narrative; else Balanced. Region: ≥0.60 Precision; ≤0.40 Narrative; else Balanced.
- Presets: Precision 2.5–3.5k; Narrative 5–8k; Balanced 4–5k; overlap 250–300.
- Transitional chunk on preset switches; sticky decisions require ≥0.10 delta across two regions.
- Borderline episodes: run micro A/B on the first segment and pick the better preset.

## Quality Gates (must report)
- Rare‑retention ≥95%; high‑novelty coverage ≥90%; contradictions surfaced ≥80%.
- Verification pass on top 20% claims; retrieval precision/recall.
- If any gate fails → write `refine_plan.json`, re‑read targets only, re‑synthesize.

## Artifacts
`final.md`, `global_context.json`, `ledger.sqlite`, `artifacts.sqlite`, `scorecard.json`, `refine_plan.json`, plus debug bundle (`llm_calls.jsonl`, `decision_log.json`, `verification_log.json`, `evolution_timeline.json`, `link_graph.dot`, `token_trace.csv`, `chunking_decisions.json`).